{# Local Variables: #}
{# mode: jinja2 #}
{# End: #}

@kosma-init

begin procedure radiometer_noise
    !
    def real NEB corr
    ! Faktor Radiometer formula
    let corr 'sqrt(2)'
    !assume all otf_total_power
    let corr 1.0
     
    ! Noise equivalent Bandwidth of the XFFTS Spectrometers
    let NEB 1.0
    if .not.exist(sigma_radiometer) then
    def real sigma_radiometer /global
    def real sigma_radiometer_no_tau /global    
    endif
    if tau_signal.ne.0 then
        let sigma_radiometer 'corr*(TSYS/sqrt(abs(freq_step*1e6*NEB)*time))*exp(tau_signal/sin(elevation))'
        let sigma_radiometer_no_tau 'corr*(TSYS/sqrt(abs(freq_step*1e6*NEB)*time))'        
    else
        let sigma_radiometer 1000.0
        let sigma_radiometer_no_tau 1000.0        
    endif
 
end procedure radiometer_noise

file in "{{ input_file }}"
say "getting rms data"


if .not.exist(error_flag) then;
   def int error_flag /global
endif

on error let error_flag 1

set var user
import sofia

set unit v

{% if windows != "" %}
set window {{ windows }}
{% endif %}



find /all

if set%las%wind2[1].eq.0 then
   say "ERROR: no windows set, no rms column added taken"
   exit 0
endif

sic message class s-f
sic message class -FEWRIU
sic message sic -FEWRIU
SIC MESSAGE GLOBAL ON

sic output "{{memory_dir}}/pandas_rms.csv"
! columns



def int smooth_levels 
let smooth_levels  3
def int smooth_box_size
let smooth_box_size 10

def real rms_level['smooth_levels+1']
def real rms_level_channel_size['smooth_levels+1']
def real sigma_before_despike
def int fft_len[8]
def real ry_pos

!
! write table header
!
def char*1000 output_header
def char*1000 output_line
let output_header "index,number,version,rms,rms_radiometer,rms_radiometer_ratio,rms_despike,rms_radiometer_no_tau,rms_radiometer_no_tau_ratio,tau_signal,elevation,tsys"
for i 1 to smooth_levels
    output_header = 'output_header'",rms_smooth_level_"'smooth_box_size*i'
next i
output_header = 'output_header'",radiometer_fit_param_0,radiometer_fit_param_1"

{% if fft_definitions != "" %}
{{ fft_definitions }}
{% endif %}
for i 1 to found
    get n
    if exist(R%ASSOC%line%data) then
       set window /ASSOCIATED
    else
       set window {{ windows }}
    endif
    @radiometer_noise
    !
    base 0
    if error_flag.eq.0 then
        ! flag channels over a certain sigma and redo rms
        let sigma_before_despike sigma
        del /var ry_pos
        def real ry_pos /like ry
        let ry_pos (ry**2)**0.5
        let ry r%head%spe%bad /where ry_pos.gt.'5*sigma_before_despike'
        base 0
        !
        output_line = 'IDX%IND[i]'","'number'","'R%HEAD%GEN%VER'","'sigma_before_despike','sigma_radiometer','sigma/sigma_radiometer','sigma','sigma_radiometer_no_tau','sigma/sigma_radiometer_no_tau','tau_signal','elevation','tsys'
    else
        output_line = 'IDX%IND[i]'","'number'","'R%HEAD%GEN%VER'",9999,9999,9999,9999,9999,9999,"'tau_signal','elevation','tsys'
        let error_flag 0
    endif
    !
    rms_level[1] = 'sigma'
    rms_level_channel_size[1] = 'abs(freq_step)'
    !
    for j 1 to smooth_levels
        smooth box 'smooth_box_size'
        base 0
        if error_flag.eq.0 then
            output_line = 'output_line'","'sigma'
            rms_level['j+1'] = 'sigma'
            rms_level_channel_size['j+1'] = 'abs(freq_step)'
        else
            output_line = 'output_line'",9999"
            let error_flag 0
        endif
    next j
    ! fit slope of smoothed data and fit
    MFIT rms_level=(&M*rms_level_channel_size + &C) 
    output_line = 'output_line'","'MFIT%PAR[1]'","'MFIT%PAR[2]'
    {% if fft_definitions != "" %}
    get 
    @fft_focus
    !
    ! write header on first pass
    !
    if i.eq.1 then
        compute fft_len dimof fft_focus
        for jj 1 to fft_len[1]
            output_header = 'output_header'",fft_power_"'fft_focus[jj,1]'
        next jj
        say 'output_header'
    endif
    !
    ! write fft values
    !
    for jj 1 to fft_len[1]
        output_line = 'output_line'","'fft_focus[jj,3]'
    next jj
    {% else %}
    if i.eq.1 then
        say 'output_header'
    endif
    {% endif %}
    say 'output_line'
    !
    let error_flag 0
    sic message class s+i
next

sic output
exit
