
from __future__ import print_function
import pyclass
import os
import math
import pandas as pd
from sicparse import OptionParser
import numpy as np
import matplotlib.pyplot as pyplt
from kosma_py_lib.pandas_index import get_index
from datetime import datetime
from scipy.optimize import curve_fit


def onpick(event):
    ind = event.ind
    # print event
    # print len(event.artist.get_xdata()), len(event.artist.get_ydata())
    # print event.artist._offsets[:,1]
    index = map(int, event.artist._offsets[:, 0][ind])
    # return
    print(
        plot_df.loc[index][
            ['scan', 'subscan', 'version', 'telescope', 'loff', 'boff']
        ]
    )
    for i, (number, version) in enumerate(
        zip(plot_df.loc[index].index, plot_df.loc[index].version)
    ):
        pyclass.comm('get {0} {1}'.format(number, version))
        print(
            plot_df.loc[index].telescope.values,
            plot_df.loc[index].scan.values,
            plot_df.loc[index].subscan.values
        )
        if options.smooth_spectra > 1:
            pyclass.comm('smooth box {0:3.0f}'.format(options.smooth_spectra))
        if i == 0:
            pyclass.comm('pen 0')
            pyclass.comm('clear')
            pyclass.comm('pl')
            pyclass.comm('draw window')
        else:
            pyclass.comm('pen {0}'.format(i % 6))
            pyclass.comm('spec')
    return


# fitting function for gauss
def gauss(x, a, x0, sigma):
    return a * np.exp(-(x - x0)**2 / (2 * sigma**2))


def fit_gauss(x, y):
    max_idx = np.argmax(y)
    amp = y[max_idx]
    offset = x[max_idx]
    width = 10.0
    if max_idx == 0:
        return
    #
    # popt, pcov = curve_fit(gauss, x, y,
    #                        [amp, offset, width],
    #                        bounds=[(0.01, 10), (1, 16), (0.01, 10)]
    #                        )
    try:
        popt, pcov = curve_fit(gauss, x, y, [amp, offset, width], bounds=(
            [amp * 0.3, offset * 0.3, 1.0], [amp * 3, offset * 3, 100.0]))
        # popt, pcov = curve_fit(gauss,x,y, [amp, offset, width])
    except:
        return
    # fitted parameters
    # fitted_amp = popt[0]
    # fitted_offset = popt[1]
    # fitted_width = popt[2]
    return {"amp": popt[0], "offset": popt[1], "width": popt[2]}


def main():
    parser = OptionParser()
    description = '''
script to plot the pandas index generated by the get_index command
points in the plot can be selected and the corresponding plot will be show
in the class plot window

# example plot rms (use /get_rms option to generate rms column)
plot_index /xaxis number /yaxis rms

# example plot rms, groupby telescope
plot_index /xaxis number /yaxis rms /group_by telescope

# example plot rms, groupby telescope, generate histogram with 100 bins a
# limit of 0 to 10
plot_index /xaxis number /yaxis rms /group_by telescope /ylim 0 10 -
           /histogram 100

# example plot rms, groupby telescope, generate histogram with 100 bins a
# limit of 0 to 10 change points size in plot to 0.3
plot_index /xaxis number /yaxis rms /group_by telescope /ylim 0 10 -
           /histogram 100 /plot_kwargs "{'s':0.3}"

# example plot rms, groupby telescope, generate histogram with 100 bins a
# limit of 0 to 10 change points size in plot to 0.3
plot_index /xaxis boff /yaxis rms /yaxis line_int_mean /group_by telescope -
           /group_by source /group_by_row subscan -
           /plot_kwargs "{'linestyle':'-'}" /histogram 10plot_index -
           /xaxis number /yaxis rms /group_by telescope /ylim 0 10 -
           /histogram 100 /plot_kwargs "{'s':0.3}"

# example plot rms, groupby telescope, generate histogram with 100 bins a
# limit of 0 to 10 and only plot spectra with version number 7
plot_index /xaxis number /yaxis rms /group_by version /ylim 0 10 -
           /histogram 500 /table_filters "version == 7"

# you can chain table filters together
# example plot rms, groupby telescope, generate histogram with 100 bins a
# limit of 0 to 10 and only plot spectra with version number 7 and spectra
# with an rms greater than 3 time the mean rms
plot_index /xaxis number /yaxis rms /group_by version /ylim 0 10 /histogram 500
           /table_filters "version == 7" /table_filters "rms>rms.mean()"

# or rms greater than the mean rms + 3 times the standard deviation
plot_index /xaxis number /yaxis rms /group_by version /ylim 0 10 -
           /histogram 500 /table_filters "version == 7" -
           /table_filters "rms>(rms.mean()+3*rms.std())"

#
plot_index /yaxis rms  /fit_gauss /group_by version /group_by_row telescope -
           /group_by_row mission_id -
           /ylim "{'rms' : [0,100], 'stats_median' : [-30,30]}" -
           /histogram 100

# adjust plot_size, default is 10,10
plot_index /xaxis boff /yaxis rms /yaxis line_int_mean /group_by telescope -
           /group_by source /group_by_row subscan
           /plot_kwargs "{'figsize': (10,5)}" /histogram 10

# Create a grid view of only the histograms
plot_index /reload_python_var /xaxis number /yaxis rms -
           /group_by source /group_by_row telescope /histogram 150  -
           /save_filename "pca_before_after_rms_comparison.png" -
           /only_histogram /n_columns 3 /plot_kwargs "{'figsize':(15,15)}"

'''
    parser = OptionParser(description)
    parser.add_option("-x", "--xaxis", default="number",
                      dest="xaxis", nargs=1)
    parser.add_option("-y", "--yaxis", default=[], action="append",
                      dest="yaxis", nargs=1)
    parser.add_option("-g", "--group_by", default=[], action="append",
                      dest="group_by", nargs=1)
    parser.add_option("-g", "--group_by_row", default=[], action="append",
                      dest="group_by_row", nargs=1)
    parser.add_option("-r", "--reload", default=False,
                      dest="reload", action="store_true")
    parser.add_option("-y", "--ylim", default="",
                      dest="ylim", type=str)
    parser.add_option("--histogram", default=0.0,
                      dest="histogram")
    parser.add_option("--histogram_normalize", default=False,
                      dest="histogram_normalize", action="store_true")
    parser.add_option("--fit_gauss", default=False,
                      dest="fit_gauss", action="store_true")
    parser.add_option("--save_filename", default="",
                      dest="save_filename")
    parser.add_option("-f", "--table_filters", default=[], action="append",
                      dest="table_filters", nargs=1)
    parser.add_option("-r", "--reload_python_var", default=False,
                      dest="reload_python_var", action="store_true")
    parser.add_option("--smooth_spectra", default=0.0, type=float,
                      dest="smooth_spectra")
    parser.add_option("-k", "--plot_kwargs", default="{}",
                      dest="plot_kwargs", nargs=1)
    parser.add_option("--only_histogram", default=False, action="store_true",
                      dest="only_histogram")
    parser.add_option("--n_columns", default=0,
                      dest="n_columns")
    #
    if (not pyclass.gotgdict()):
        pyclass.get(verbose=False)
    try:
        global options
        (options, args) = parser.parse_args()
    except:
        pyclass.message(pyclass.seve.e, "plot_unique", "Invalid option")
        pyclass.sicerror()
        return
    print(options)

    if options.n_columns and not options.only_histogram:
        pyclass.message(
            pyclass.seve.e,
            "n_columns",
            "Can only be used together with the only_histogram flag"
        )
        pyclass.sicerror()
        return

    options.plot_kwargs = eval(options.plot_kwargs)
    pyclass.comm("set var user")
    pyclass.comm("import sofia")
    #
    # df = get_index(
    #     observatory="SOFIA_GREAT",
    #     additional_meta_parameters=options.additional_meta_parameters,
    #     force_reload=options.reload, get_rms=options.get_rms
    #     )
    global df
    if "df" not in globals():
        options.reload_python_var = True
    else:
        print("pandas table already in memory")
        print(df.columns)

    if (options.reload_python_var) or (options.reload):
        df = get_index(observatory="SOFIA_GREAT",
                       force_reload=options.reload)
    #
    if df is None:
        return
    # filter df based on index numbers
    global plot_df
    # plot_df = df.loc[list(pyclass.gdict.idx.ind.__sicdata__)].dropna()
    plot_df = df.loc[pyclass.gdict.idx.num.__sicdata__]
    # filter
    if len(options.table_filters) > 0:
        # rms<10
        tables = []
        for table_filter in options.table_filters:
            try:
                tables.append(plot_df[plot_df.eval(
                    table_filter, engine="python")])
            except:
                pyclass.message(
                    pyclass.seve.e,
                    "plot_index",
                    "{0} failed, check columns names:\{1}".format(
                        table_filter, "\n".join(plot_df.columns)
                    )
                )
                return
            plot_df = pd.concat(tables, verify_integrity=False)
    if len(plot_df) == 0:
        pyclass.message(pyclass.seve.e, "plot_index", "no data found in table")
        return
    #
    #
    if options.xaxis == "number":
        options.xaxis = "index"
    #
    if len(options.yaxis) == 0:
        pyclass.message(
            pyclass.seve.e,
            "plot_index",
            ("no Y axis selected with yaxis option "
             "following columns available\n{1}").format(
                options.yaxis, "\n".join(plot_df.columns))
        )
        return
    #
    for yaxis in options.yaxis:
        if (yaxis not in plot_df.columns):
            pyclass.message(
                pyclass.seve.e,
                "plot_index",
                ("Y axis column {0} not found, "
                 "following columns available\n{1}").format(
                    options.yaxis, "\n".join(plot_df.columns)
                )
            )
            return
    if (options.xaxis != "index" and options.xaxis not in plot_df.columns):
        pyclass.message(
            pyclass.seve.e,
            "plot_index",
            ("X axis column {0} not found, "
             "following columns available\n{1}").format(
                options.xaxis, "\n".join(plot_df.columns)
            )
        )
        return
    # check_ylim are consistent
    if "{" in options.ylim:
        # parse as dictionary
        ylim_dict = eval(options.ylim)
    elif options.ylim == "":
        ylim_dict = {}
    elif len(eval(options.ylim)) == 2:
        # parse as list
        ylim_dict = {"common": [float(lim) for lim in eval(options.ylim)]}
    #
    print(options.plot_kwargs)
    fig = pyplt.figure(figsize=options.plot_kwargs.pop("figsize", (10, 10)))
    plot_dict = {}
    # check that there are unique axis
    options.yaxis = list(set(options.yaxis))
    #
    axes_groups = []
    if len(options.group_by_row) > 0:
        for group, table_group in plot_df.groupby(options.group_by_row):
            for order, yaxis in enumerate(options.yaxis):
                if type(group) == tuple:
                    axes_group = list([str(row) for row in group])
                    axes_group.append(yaxis)
                    axes_groups.append(axes_group)
                else:
                    axes_groups.append([str(group), yaxis])
    else:
        axes_groups = [[option] for option in options.yaxis]
    print(axes_groups)
    #
    axes_base_tag = "".join([str(ele) for ele in axes_groups[0]])

    if options.only_histogram and not options.n_columns:
        plot_columns = 1
        order_modifier = 1
    else:
        plot_columns = 2
        order_modifier = 2

    if options.n_columns and options.only_histogram:
        plot_columns = int(options.n_columns)
        order_modifier = 1
    hist_base_tag = None
    for order, group in enumerate(axes_groups):
        axes_tag = "".join([str(ele) for ele in group])
        if options.histogram == 0.0:
            if order == 0:
                plot_dict["data_{0}".format(axes_tag)] = fig.add_subplot(
                    len(axes_groups), 1, order + 1)
            else:
                plot_dict["data_{0}".format(axes_tag)] = fig.add_subplot(
                    len(axes_groups), 1, order + 1,
                    sharex=plot_dict["data_{0}".format(axes_base_tag)]
                )
        else:
            if not options.only_histogram:
                if order == 0:
                    plot_dict["data_{0}".format(axes_tag)] = fig.add_subplot(
                        len(axes_groups), plot_columns,
                        order_modifier * (order + 1) - 1)
                else:
                    plot_dict["data_{0}".format(axes_tag)] = fig.add_subplot(
                        len(axes_groups), plot_columns, order_modifier *
                        (order + 1) - 1,
                        sharex=plot_dict["data_{0}".format(axes_base_tag)]
                    )
            # histograms
            if options.n_columns:
                number_of_rows = math.ceil(
                    float(len(axes_groups)) / int(plot_columns))
                if not hist_base_tag:
                    hist_base_tag = "hist_{0}".format("".join(group))
                    plot_dict[
                        "hist_{0}".format("".join(group))
                    ] = fig.add_subplot(
                        number_of_rows, plot_columns, order_modifier *
                        (order + 1),
                    )
                else:
                    plot_dict[
                        "hist_{0}".format("".join(group))
                    ] = fig.add_subplot(
                        number_of_rows, plot_columns, order_modifier *
                        (order + 1),
                        sharex=plot_dict[hist_base_tag],
                        sharey=plot_dict[hist_base_tag]
                    )
                plot_dict["hist_{0}".format("".join(group))].set_title(
                    ",".join(group), x=0.3, y=0.9
                )
            else:
                number_of_rows = len(axes_groups)
                plot_dict["hist_{0}".format("".join(group))] = fig.add_subplot(
                    number_of_rows, plot_columns, order_modifier * (order + 1)
                )
                plot_dict["hist_{0}".format("".join(group))].set_title(
                    ",".join(group),
                )
        if not options.only_histogram:
            plot_dict["data_{0}".format(axes_tag)].set_title(",".join(group))

    #

    gauss_fits = []
    # check that options are valid
    for column in options.group_by:
        if column not in plot_df.columns:
            pyclass.message(
                pyclass.seve.e,
                "plot_unique",
                "Column {0} not found, skipping in grouping".format(column)
            )
            options.group_by.remove(column)
    # if len(options.group_by) == 0:
    #     pyclass.message(
    #         pyclass.seve.e,
    #         "plot_unique",
    #         "column {0} not found, following columns available\n{1}".format(
    #             options.xaxis,
    #             "\n".join(plot_df.columns)
    #         )
    #     )
    #     return
    if len(options.group_by) > 0:
        table_groups = plot_df.groupby(options.group_by)
    else:
        table_groups = [("", plot_df)]
    #
    for group, table_group in table_groups:
        group = str(group)
        group_dict = dict(zip(options.group_by, str(group)))
        for yaxis in options.yaxis:
            if len(options.group_by_row) == 0:
                row_groups = [("", table_group)]
            else:
                row_groups = table_group.groupby(options.group_by_row)
            #
            for order, (row_group, row_group_table) in enumerate(row_groups):
                if type(row_group) == tuple:
                    row_group = list(row_group)
                else:
                    row_group = [row_group]
                #
                default_ylim = ylim_dict.get(
                    "common",
                    [min(table_group[yaxis].values),
                     max(table_group[yaxis].values)]
                )
                ylim = ylim_dict.get(yaxis, default_ylim)
                if default_ylim[1] >= ylim[1]:
                    ylim[1] = default_ylim[1]
                    ylim_dict[yaxis] = ylim
                if default_ylim[0] <= ylim[0]:
                    ylim[0] = default_ylim[0]
                    ylim_dict[yaxis] = ylim
                #
                axes_tag = "{0}{1}".format(
                    "".join([str(row) for row in row_group]),
                    yaxis
                )
                if options.histogram != 0.0:
                    #
                    n, bins = np.histogram(
                        row_group_table[yaxis].values,
                        bins=int(options.histogram),
                        range=ylim,
                        density=options.histogram_normalize
                    )
                    bincenters = 0.5 * (bins[1:] + bins[:-1])
                    line_hist, = plot_dict["hist_{0}".format(axes_tag)].step(
                        bincenters, n, label=str(group), where='mid'
                    )
                    plot_dict["hist_{0}".format(axes_tag)].set_xlabel(yaxis)
                    #
                    if options.fit_gauss:
                        params = fit_gauss(bincenters, n)
                        if params is not None:
                            group_dict.update(params)
                            gauss_fits.append(group_dict)
                            fit_label = ("{1}\noffset {0[offset]:3.2f}, "
                                         "sigma {0[width]:3.2f}, "
                                         "amplitude {0[amp]:3.2f}").format(
                                params, group
                            )
                            line_hist.set_label(fit_label)
                            _ = plot_dict["hist_{0}".format(axes_tag)].plot(
                                bincenters,
                                gauss(
                                    bincenters, params["amp"],
                                    params["offset"],
                                    params["width"]
                                ),
                                "--",
                                color=line_hist.get_color(),
                                label=""
                            )
                            _ = plot_dict[
                                "hist_{0}".format(axes_tag)
                            ].set_aspect(1)
                            #
                    if order == 0:
                        pass
                        #    plot_dict["hist_{0}".format(axes_tag)].legend()
                #
                # value series

                #
                legend_label = "\n".join([group[i:i + 40]
                                          for i in range(0, len(group), 40)])

                if options.xaxis == "timestamp" and not options.only_histogram:
                    plot_dict["data_{0}".format(axes_tag)].plot_date(
                        getattr(row_group_table, options.xaxis).astype(
                            datetime
                        ),
                        getattr(row_group_table, yaxis),
                        label=str(legend_label),
                        picker=True,
                        **options.plot_kwargs
                    )
                else:
                    if not options.only_histogram:
                        plot_dict["data_{0}".format(axes_tag)].scatter(
                            getattr(row_group_table, options.xaxis),
                            getattr(row_group_table, yaxis),
                            label=str(legend_label),
                            picker=True,
                            **options.plot_kwargs
                        )
                #
                if not options.only_histogram:
                    plot_dict["data_{0}".format(
                        axes_tag)].set_xlabel(options.xaxis)
                    plot_dict["data_{0}".format(axes_tag)].set_ylabel(yaxis)
                    #                    
                    #plot_dict["data_{0}".format(axes_tag)].set_ylim(ylim)
                    if order == 0:
                        plot_dict["data_{0}".format(axes_tag)].legend()
                if options.only_histogram:
                    if order == 0:
                        plot_dict["hist_{0}".format(axes_tag)].legend()
                    if (order % int(options.n_columns)):
                        plot_dict[
                            "hist_{0}".format(axes_tag)
                        ].get_yaxis().set_visible(False)
                #

    fig.canvas.mpl_connect('pick_event', onpick)
    # parse plot options
    #
    # if len(options.ylim)>0:
    #    ax_data.set_ylim(options.ylim)
    # lgnd = pyplt.legend(fontsize="small")
    # for handle in lgnd.legendHandles:
    #    handle.set_sizes([20.0])
    #
    if options.n_columns:
        pyplt.subplots_adjust(wspace=0, hspace=0)
    else:
        pyplt.tight_layout()
    if options.save_filename == "":
        pyplt.show()
    else:
        options.save_filename = options.save_filename.replace(" ", "")
        fig.suptitle(os.path.basename(options.save_filename))
        path = os.path.dirname(options.save_filename)
        if (path != "") and (not os.path.exists(path)):
            os.mkdir(os.path.dirname(options.save_filename))
        print("saving {0}".format(options.save_filename))
        pyplt.savefig(options.save_filename)
        # save gauss fits to pickle
        table_gauss_fit = pd.DataFrame(gauss_fits)
        table_gauss_fit.to_pickle(os.path.splitext(
            options.save_filename)[0] + ".pkl"
        )


if __name__ == "__main__":
    main()
